% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/DW_Server.R
\name{DW_fetch_available_sources}
\alias{DW_fetch_available_sources}
\title{Fetch Available Source}
\usage{
DW_fetch_available_sources(state, session, dw_view = NULL)
}
\arguments{
\item{state}{DW state object}

\item{session}{Shiny session variable}

\item{dw_view}{Optoinal data view to use as a reference point for DW data sources}
}
\value{
list with the following elements
\itemize{
  \item{choices:} List of values to use with selectInput()/pickerInput()
  \itemize{
    \item{plain:}  Raw vector of choices
    \item{labeled:} Named vector of choices
    \item{grouped:} Choices grouped by module
  }
  \item{catalog:} Dataframe containing the a tabular catalog of the
  datasets found.
  \itemize{
    \item{label:} Text label
    \item{object:} Name of the R Object containing the data frame
    \item{MOD_TYPE:} Short name of the type of module
    \item{id:} Module ID
    \item{idx:} Numerical identifier within the module
    \item{res_label: optional label that can be defined by a user and used in
    workflows. Must be unique to the module.}
    \item{checksum:} Module checksum
    \item{DSchecksum:} Checksum of the dataset
    \item{code:} Code to generate the dataset
  }
  \item{FM_objs:} List of object names that come from other formods modules
  \item{DW_objs:} List of object names that come from the current DW module 
}
}
\description{
Returns a list of avaliable data sources for a given data wrangling
element. This includes any modules the DW module can pull from (e.g. UD and
DM) as well as any data views defined before the provided \code{dw_view}.
If \code{dw_view} is NULL then only the sources from the modules DW is
dependent on will be returned.
}
\examples{
library(formods)
# The example requires a formods DW state object
sess_res = DW_test_mksession()
state    = sess_res$state
session  = sess_res$session

state[["DW"]][["ui"]][["select_dw_element"]]          = "filter"
state[["DW"]][["ui"]][["select_fds_filter_column"]]   = "EVID"
state[["DW"]][["ui"]][["select_fds_filter_operator"]] = "=="
state[["DW"]][["ui"]][["fds_filter_rhs"]]             = 0

# This builds the data wrangling statement based on
# elemets scraped from the UI
dwb_res  = dwrs_builder(state)

# Here we evaluate the resulting command:
dwee_res = dw_eval_element(state, dwb_res[["cmd"]])

# Next we add this wrangling element to the state
state    = DW_add_wrangling_element(
             state    = state, 
             session  = session,
             dwb_res  = dwb_res, 
             dwee_res = dwee_res)

# This creates a new data view and makes it active
state = DW_new_view(state)

# Here we can pluck out that data view from the state
current_view = DW_fetch_current_view(state)

# This will update the key in this view
current_view[["key"]] = "My new view"

# And this will place it back into the state
state = DW_set_current_view(state, session, current_view)

# This will pull out the available sources for the current data view.
# This is used when doing merging:
avail_ds = DW_fetch_available_sources(state, session, dw_view=current_view)

# This will pull out the meta data for a given object
ds_obj  = avail_ds[["catalog"]][["object"]][1]
ds_meta = DW_fetch_obj_ds_meta(
            state   = state, 
            session = session, 
            dw_view=current_view, 
            ds_obj=ds_obj)
}
